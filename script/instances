#!/usr/bin/env ruby

# Load libraries
require "rubygems"
require "yaml"
require "AWS"

if ARGV.length < 4
  puts "ruby script/instances <environment> <task> <type> <count>"
  exit
elsif !['staging','production'].include? ARGV[0]
  puts "instance environments are - staging,production"
  exit
elsif !['create','destroy'].include? ARGV[1]
  puts "instance tasks are - create,destroy"
  exit
elsif !['web','proc'].include? ARGV[2]
  puts "instance types are - web,proc"
  exit
end

# Move command line arguments into named variables
environment = ARGV[0]
task        = ARGV[1]
type        = ARGV[2]
count       = ARGV[3].to_i

puts environment
puts task
puts type
puts count

# Load rails config
config = YAML.load_file("config/config.yml")[environment]

# Create object for interfacing with AWS EC2 api
ec2 = AWS::EC2::Base.new(
        :access_key_id      => config[:aws_access_id],
        :secret_access_key  => config[:aws_secret_key])

# Create object for interfacing with AWS ELB api
elb = AWS::ELB::Base.new(
        :access_key_id      => config[:aws_access_id],
        :secret_access_key  => config[:aws_secret_key])


case task
when "create"

  response = ec2.run_instances(
    :image_id           => 'ami-41bf7528',
    :min_count          => count,
    :max_count          => count,
    :instance_type      => 't1.micro',
    :availability_zone  => 'us-east-1b',
    :security_group     => 'sg-7c5fca15')

  instances = response.instancesSet.item

  sleep 3

  ec2.create_tags(
    :resource_id  => instances.map(&:instanceId),
    :tag          => [
                      {'Name' => "Closet #{environment.capitalize} "\
                                  "#{type.capitalize}"},
                      {'Installed' => '0'}])

when "destroy"
    case type
    when "web"
      balancers = elb.describe_load_balancers.DescribeLoadBalancersResult.
                    LoadBalancerDescriptions.member
      balancer  = balancers.select{|b| b.LoadBalancerName.
                              scan(environment).length > 0}.first

      raise IOError, "No elb found for environment" if balancer.nil?

      instances = balancer.Instances.member.map(&:InstanceId)

      raise IOError, "Too few instances on elb" if count > instances.length

      selected_instances = instances[0..count-1]

      elb.deregister_instances_from_load_balancer(
        :instances          => selected_instances,
        :load_balancer_name => balancer.LoadBalancerName)

      ec2.terminate_instances(:instance_id => selected_instances)

    when "proc"
      instances = ec2.describe_instances.reservationSet.item.map do |group| 
                    group.instancesSet.item
                  end.flatten
      instances = instances.select do |instance|
                      next unless instance.instanceState.code == "16"

                      tags = instance.tagSet.item
                      next unless tags.length > 0

                      install_tag = tags.select{|t| t.key == "Installed"}
                      next unless install_tag.length > 0

                      install_status = install_tag.first.value
                      next unless install_status == '1'
                      
                      true
                  end

      proc_server_regex = Regexp.new("Closet #{environment.capitalize} "\
                                      "Proc")
      proc_servers = instances.select do |instance| 
                      tags = instance.tagSet.item
                      next unless tags.length > 0

                      name_tag = tags.select{|t| t.key == "Name"}
                      next unless name_tag.length > 0

                      name = name_tag.first.value
                      next unless name.scan(proc_server_regex).length > 0

                      true
                    end
      
      raise IOError, "Too few proc instances" if count > proc_servers.length

      ec2.terminate_instances(
        :instance_id => proc_servers.map(&:instanceId)[0..count-1])
    end
end
